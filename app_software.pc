/*
 * 
 * Marco Mart�nez S�nchez (marco.msanchez@udc.es)
 * Juan Luis Filguieras Rilo (juan.filgueiras.rilo@udc.es)
 * Universidade da Coru�a
 *
 * BDA - Curso 2018/19
 *
 * TGR BDA aplicado a unha empresa de desenvolvemento software.
 *
 */

#include<stdlib.h>
#include<stdio.h>
#include<string.h>




EXEC SQL INCLUDE SQLCA;

/*
 * Utilidades para men�s e ler valores por teclado. 
 * En "teclado.c" est�n repetidas con exemplos de uso 
 */
#define MAXLEN 20
void get_string(char *s, int maxlen){
	fgets(s,maxlen,stdin);
	int last = strlen(s) -1;
	if ( (s[last]=='\r') || (s[last]=='\n') )
		s[last] = '\0';
}

void get_password(char *s, int maxlen){
	system("stty -echo");
	get_string(s,maxlen);
	system("stty echo");
}

int get_int(){
	char s[MAXLEN];
	get_string(s,MAXLEN);
	return atoi(s);
}

float get_float(){
	char s[MAXLEN];
	get_string(s,MAXLEN);
	return atof(s);
}

int menu()
{
  int opcion = -1;

  int MAXOPTS = 15; /* N�mero de opci�ns do men� */

  printf("Men� da aplicaci�n\n");
  printf("=========DESENVOLVEDORES=========\n\n");
  printf("1. Engadir desenvolvedor\n");
  printf("2. Borrar desenvolvedor\n");
  printf("3. Ver detalle de desenvolvedor\n");
  printf("4. Listar desenvolvedores\n");
  printf("5. Modificar salario\n");
  printf("=========PROXECTOS=========\n\n");
  printf("6. Engadir proxecto\n");
  printf("7. Nomear xefe de proxecto\n");
  printf("8. Modificar data de fin\n");
  printf("=========M�DULOS=========\n\n");
  printf("9. Engadir m�dulo dun proxecto\n");
  printf("10. Borrar m�dulo dun proxecto\n");
  printf("11. Listar m�dulos\n");
  printf("=========EMPREGADOS=========\n\n");
  printf("12. Asignar empregado a m�dulo\n");
  printf("13. Desasignar empregado de m�dulo\n");
  printf("14. Buscar empregados por m�dulo\n");
  printf("15. Buscar empregados por proxecto\n");
  printf("16. Buscar xefes de proxecto\n");

  printf("0. Sa�r\n");

  while ( (opcion < 0) || (opcion > MAXOPTS)){
      printf("OP> ");
      opcion=get_int();
  }
  return opcion;
}






/* Funcionalidadess de base de datos */

void xestiona_erroconexion(){

	exec sql whenever sqlerror continue;
	switch(sqlca.sqlcode){
		case -1017:
		case -1005: printf("Erro conectando a Oracle\n\n");
			exit(-1);
		case -1012: printf("Erro desconectando de Oracle\n\n");
			break;
		default: 
			printf("Erro %d: %.*s\n",
			sqlca.sqlcode,
			sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	}
}

int xestiona_erroddl(char *taboa){
	exec sql whenever sqlerror continue;
	int cod = sqlca.sqlcode;
	switch(cod){
		case -955: printf("A t�boa %s xa existe, non se crea\n", taboa);
			break;
		case -942: printf("A t�boa %s non existe, non se borra\n", taboa);
			break;
	}
	return cod;
}


int xestiona_errodml(int do_rollback, char *taboa){
	exec sql whenever sqlerror continue;
	int cod = sqlca.sqlcode;
	switch(cod){
		case -1: printf("Xa existe un %s con ese c�digo, non se crea.\n", taboa);
			break;
		default: 
			printf("Erro %d: %.*s\n",
			sqlca.sqlcode,
			sqlca.sqlerrm.sqlerrml, sqlca.sqlerrm.sqlerrmc);
	}

	if (do_rollback)
		exec sql rollback;

	return cod;
}

void conecta_bd(){
	exec sql whenever sqlerror do xestiona_erroconexion();
	exec sql begin declare section;	
	char usuario[30], clave[30];
	exec sql end declare section;

	printf("Conectando con Oracle...\n");
	printf("Usuario: "); get_string(usuario, 29);
	printf("Clave: "); get_password(clave, 29);

	EXEC SQL CONNECT :usuario IDENTIFIED BY :clave;

}

void desconecta_bd(){
	exec sql whenever sqlerror do xestiona_erroconexion();
	EXEC SQL COMMIT RELEASE;
	printf("Desconectado.\n");
}


void engadir_proxecto(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "proxecto");

	exec sql begin declare section;
		int codigo;
		char nome[16];
		char dataIni[16];
		char dataFin[16];
		short dataFinInd;
	exec sql end declare section;

	printf("Codigo: "); codigo=get_int();
	printf("Nome: "); get_string(nome, 15);
	printf("Data de inicio: "); get_string(dataIni, 15);
	printf("Data de fin (opcional): "); get_string(dataIni, 15);
	dataFinInd = (dataFin[0] == '\n' || dataFin[0] == '\0') ? -1 : 0;


	exec sql insert into proxecto(cod_pro,nome,dataIni, dataFin)
		values(:codigo, :nome, :dataIni, :dataFin:dataFinInd);

	if (!erro){
		exec sql commit;
		printf("\nProxecto engadido.\n");
	}

}


void nomear_xefe_proxecto(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "proxecto");

	exec sql begin declare section;
		int proxecto;
		int empregado;
	exec sql end declare section;

	printf("Codigo proxecto: "); proxecto=get_int();
	printf("Numero da Seguridade Social do empregado"); empregado=get_int();


	exec sql update proxecto set xefe_NSS = :empregado
		 where cod_pro = :proxecto;

	if (!erro){
		exec sql commit;
		printf("\nXefe engadido.\n");
	}
}


void modificar_data_fin(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "proxecto");

	exec sql begin declare section;
		int proxecto;
		char dataFin[16];
	exec sql end declare section;

	printf("Codigo proxecto: "); proxecto=get_int();
	printf("Nova data de fin"); get_string(dataFin, 15);


	exec sql update proxecto set dataFin = :dataFin
		 where cod_pro = :proxecto;

	if (!erro){
		exec sql commit;
		printf("\nData modificada.\n");
	}
}

void engadir_modulo_proxecto(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "modulo");

	exec sql begin declare section;
		int codigo;
		char nome[16];
		char tecnoloxia[16];
	exec sql end declare section;

	printf("Codigo do proxecto: "); codigo=get_int();
	printf("Nome do modulo: "); get_string(nome, 15);
	printf("Tecnoloxía: "); get_string(tecnoloxia, 15);


	exec sql insert into modulo(cod_pro,nome,tecnoloxia)
		values(:codigo, :nome, :tecnoloxia);

	if (!erro){
		exec sql commit;
		printf("\nMódulo engadido.\n");
	}

}


void borrar_modulo_proxecto(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "modulo");

	exec sql begin declare section;
		int codigo;
		char nome[16];
	exec sql end declare section;

	printf("Codigo do proxecto: "); codigo=get_int();
	printf("Nome do modulo: "); get_string(nome, 15);


	exec sql delete from modulo
		where nome = :nome and cod_pro = :codigo;

	if (!erro){
		exec sql commit;
		printf("\nMódulo eliminado.\n");
	}

}

void listar_modulos(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "modulo");

	exec sql SET TRANSACTION READ ONLY;

	exec sql begin declare section;
		int codigo;
		char nome[16];
		char tecnoloxia[16];
	exec sql end declare section;

	exec sql declare c_mod cursor for
		select cod_pro, nome, tecnoloxia
			from modulo;
	
	EXEC SQL OPEN c_mod;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	printf("\n\n");
	while(1){
		EXEC SQL FETCH c_mod INTO :codigo, :nome, :tecnoloxia;
		  printf("MODULO: \tProxecto: %d\tNome: %s\tTecnoloxia: %s.\n", 
				codigo,nome,tecnoloxia);
	}
	EXEC SQL WHENEVER NOT FOUND continue;
	printf("\nModulos atopados: %d\n", sqlca.sqlerrd[2]);
	EXEC SQL CLOSE c_mod;
	printf("\n\n");
	if (!erro)
		EXEC SQL COMMIT;

}

void asignar_empregado(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "proxecto");

	exec sql begin declare section;
		int proxecto;
		char nome[16];
		int empregado;
	exec sql end declare section;

	printf("Codigo proxecto: "); proxecto=get_int();
	printf("Nome do modulo: "); get_string(nome, 15);
	printf("Numero da Seguridade Social do empregado"); empregado=get_int();


	exec sql update modulo set nss = :empregado
		 where cod_pro = :proxecto and nome = :nome;

	if (!erro){
		exec sql commit;
		printf("\nXefe engadido.\n");
	}
}


void desasignar_empregado(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "proxecto");

	exec sql begin declare section;
		int proxecto;
		char nome[16];
		int empregado;
	exec sql end declare section;

	printf("Codigo proxecto: "); proxecto=get_int();
	printf("Nome do modulo: "); get_string(nome, 15);
	printf("Numero da Seguridade Social do empregado"); empregado=get_int();


	exec sql delete from modulo
		where nss = :empregado and cod_pro = :proxecto and nome = :nome;

	if (!erro){
		exec sql commit;
		printf("\nXefe engadido.\n");
	}
}


void listar_modulos(){
	int erro;
	exec sql whenever sqlerror do erro = xestiona_errodml(1, "modulo");

	exec sql SET TRANSACTION READ ONLY;

	exec sql begin declare section;
		int codigo;
		char nomeMod[16];
		char tecnoloxia[16];

		int nss;
		char nomeEmp[16];
		float sal;
		char tlf[20];
		char direccion[100];

	exec sql end declare section;

	exec sql declare c_mod cursor for
		select cod_pro, nome, tecnoloxia
			from modulo;
	
	EXEC SQL OPEN c_mod;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	printf("\n\n");
	while(1){
		EXEC SQL FETCH c_mod INTO :codigo, :nome, :tecnoloxia;
		  printf("MODULO: \tProxecto: %d\tNome: %s\tTecnoloxia: %s.\n", 
				codigo,nome,tecnoloxia);
	}
	EXEC SQL WHENEVER NOT FOUND continue;
	printf("\nModulos atopados: %d\n", sqlca.sqlerrd[2]);
	EXEC SQL CLOSE c_mod;
	printf("\n\n");
	if (!erro)
		EXEC SQL COMMIT;

}

void crear_taboa(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_erroddl("ARTIGO");
	exec sql create table artigo(
		codart number(2) constraint pk_artigo primary key,
		nomart varchar(15),
		prezo number(5,2)
		);

	if(!erro)
		printf("T�boa creada\n");
}

void eliminar_taboa(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_erroddl("ARTIGO");
	exec sql drop table artigo;
	if (!erro)
		printf("T�boa eliminada\n");
}





void engadir_artigo(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_errodml(1,"artigo");

	exec sql begin declare section;
		int codigo;
		char nome[16];
		float prezo;
		short prezo_ind=0;
	exec sql end declare section;

	printf("C�digo: "); codigo=get_int();
	printf("Nome: "); get_string(nome, 15);
	printf("Prezo (-1 = desco�ecido): "); prezo=get_float();

	if (prezo == -1) 
		prezo_ind=-1;

	exec sql insert into artigo(codart,nomart,prezo)
		values(:codigo, :nome, :prezo:prezo_ind);

	if (!erro){
		exec sql commit;
		printf("\nArtigo engadido.\n");
	}

}


void borrar_artigos(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_errodml(1,"artigo");

	exec sql begin declare section;
		char texto[21], patron[25];
	exec sql end declare section;

	printf("Borrar artigos que conte�en...: "); get_string(texto, 20);
	strcpy(patron, "%");
	strcat(patron,texto);
	strcat(patron,"%");

	exec sql delete from artigo
		where nomart like :patron;

	if (!erro){
		printf("\nArtigos borrados: %d.\n", sqlca.sqlerrd[2]);
		exec sql commit;
	}
}

void detalle_artigo(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_errodml(1,"artigo");

	exec sql begin declare section;
		int codigo;
		char nome[16];
		float prezo;
		short prezo_ind=0;
	exec sql end declare section;

	printf("C�digo: "); codigo=get_int();

	exec sql select nomart, prezo
			into :nome, :prezo:prezo_ind
			from artigo
			where codart = :codigo;

	if (!erro){

		if (sqlca.sqlcode==1403)
			printf("Artigo inexistente.\n");
		else{
			if (prezo_ind == -1)
				printf("Artigo: [%d, %s, --]\n", codigo, nome);
			else
				printf("Artigo: [%d, %s, %g]\n", codigo, nome, prezo);
	
		}
		exec sql commit;
	}
}


void listar_artigos(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_errodml(1,"ARTIGO");

	exec sql SET TRANSACTION READ ONLY;

	exec sql begin declare section;
		float prezomin;
		int codigo;
		char nome[16];
		float prezo; short prezo_ind;
	exec sql end declare section;

	exec sql declare c_art cursor for
		select codart, nomart, prezo
			from artigo
			where prezo > :prezomin;

	printf("Introduce prezo m�nimo: "); prezomin=get_float();
	
	EXEC SQL OPEN c_art;
	EXEC SQL WHENEVER NOT FOUND DO BREAK;
	printf("\n\n");
	while(1){
		EXEC SQL FETCH c_art INTO :codigo, :nome, :prezo:prezo_ind;
		if (prezo_ind==0)
		     printf("ARTIGO: \tC�digo: %d\tNome: %s\tPrezo: %g.\n", 
				codigo,nome,prezo);
		else
		     printf("ARTIGO: \tC�digo: %d\tNome: %s\tPrezo desco�ecido.\n", 
				codigo,nome);
	}
	EXEC SQL WHENEVER NOT FOUND continue;
	printf("\nArtigos atopados: %d\n", sqlca.sqlerrd[2]);
	EXEC SQL CLOSE c_art;
	printf("\n\n");
	if (!erro)
		EXEC SQL COMMIT;
}


void aumentar_prezo_artigo(){
	int erro=0;
	exec sql whenever sqlerror do erro=xestiona_errodml(1,"ARTIGO");

	
	
	exec sql begin declare section;
		int codigo;
		float incremento;
	exec sql end declare section;

	printf("C�digo: "); codigo=get_int();
	printf("Aumentar prezo en porcentaxe: "); incremento=get_float();

	EXEC SQL SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
	
	exec sql update artigo
		set prezo=prezo + prezo*:incremento/100
		where codart=:codigo;

	printf("PAUSA"); get_int();

	if(!erro){
		if (sqlca.sqlerrd[2])   
			printf("Artigo modificado\n");
		else
			printf("Artigo non atopado\n");
		exec sql commit;
	}

}




/* Funci�n principal */
int main()
{
  conecta_bd();

  int op;

  while ( (op=menu()) != 0){
       switch(op){
            case 1: crear_taboa(); break;
            case 2: eliminar_taboa(); break;
            case 3: engadir_artigo(); break;
            case 4: borrar_artigos(); break;
            case 5: detalle_artigo(); break;
            case 6: listar_artigos(); break;
			case 7: aumentar_prezo_artigo(); break;
       }

  }
 


 desconecta_bd(); 

 return 0;
}



